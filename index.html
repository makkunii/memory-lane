<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Memory Lane - Final</title>
<style>
:root {
  --deep-indigo: #0A0E27;
  --synth-violet: #2d1b4e;
  --neon-pink: #FF1493;
  --electric-cyan: #00FFFF;
  --ground-teal: #7c4c92;
  --ground-dark: #5e3b71;
  --platform-color: #4a6fa5;
  --platform-dark: #304e6c;
}
body {
  margin: 0;
  overflow-x: hidden; 
  overflow-y: hidden;
  background: var(--deep-indigo);
  font-family: 'Press Start 2P', monospace, sans-serif;
  color: #fff;
}
/* WORLD */
#game-container {
  position: relative;
  width: 100vw;
  min-width: 8000px;
  height: 100vh;
  background: linear-gradient(180deg, var(--deep-indigo) 0%, var(--synth-violet) 40%, #803d8d 70%, #904d9c 100%);
  display: flex;
  align-items: flex-end;
  image-rendering: pixelated;
}
/* PARALLAX */
.parallax-layer {
  position: absolute;
  top: 0; left: 0;
  width: 8000px; height: 100%;
  pointer-events: none;
  background-repeat: repeat-x;
}
#distant-mountains {
  height: calc(100% - 50px);
  bottom: 100px;
  background-image: linear-gradient(to top, var(--synth-violet) 30%, transparent 30%),
    url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 300"><path fill="%234d3b6a" d="M0 300L100 200L250 250L400 150L550 220L700 180L800 300Z" /></svg>');
  background-size: 800px 300px;
  background-position: 0% 100%;
  z-index: 5;
}

#close-clouds {
  height: 300px;
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 100"><path fill="%23a093c4" d="M0 60C20 40, 40 40, 60 60, 80 80, 100 80, 120 60, 140 40, 160 40, 180 60, 200 60L200 100L0 100Z" /></svg>');
  background-size: 400px 200px;
  background-position: 0% 10%;
  opacity: 0.3;
  z-index: 6;
}
/* TERRAIN */
#ground {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 8000px;
  height: 130px;
  background: repeating-linear-gradient(45deg, var(--ground-teal), var(--ground-teal) 10px, var(--ground-dark) 10px, var(--ground-dark) 20px);
  border-top: 5px solid var(--electric-cyan);
  box-shadow: 0 -8px 0 rgba(0,0,0,0.4) inset,
              0 0 10px var(--electric-cyan);
  z-index: 8;
}
/* PLATFORMS */
.platform {
  position: absolute;
  width: 200px;
  height: 20px;
  background: var(--platform-color);
  border: 3px solid var(--platform-dark);
  box-shadow: 0 4px 0 var(--platform-dark),
              inset 0 2px 0 rgba(255,255,255,0.4),
              inset -2px 0 0 #5f80b9,
              0 0 10px rgba(74, 111, 165, 0.8);
  z-index: 10;
  border-radius: 2px;
  image-rendering: pixelated;
}

/* PLAYER CONTAINER */
#player {
  position: absolute;
  width: 100px;
  height: 100px;
  bottom: 130px; /* adjust based on ground */
  left: 100px; /* initial position */
  pointer-events: none;
  z-index: 10;
  /* Add these two for turning the character */
  transform: scaleX(1);
  transition: transform 0.1s;
}

/* PIXEL SPRITE IMAGE */
#mjay-pixel {
  width: 100%;
  height: 100%;
  image-rendering: pixelated; /* keeps that 8-bit sharpness */
  /* Remove any conflicting animation CSS from the previous attempt */
  animation: none !important; 
}

/* Optional: floating effect like classic 8-bit hover - only active when NOT walking or jumping */
#player:not(.is-walking):not(.is-jumping) {
  animation: float 2s ease-in-out infinite;
}

@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-3px); }
}


.memory-spot {
  width:40px;height:40px;
  background:linear-gradient(135deg,var(--neon-pink)0%,#ff1493 100%);
  border:4px solid var(--electric-cyan);
  position:absolute; bottom:140px;
  animation: memory-float 2s ease-in-out infinite;
  cursor:pointer; display:flex; align-items:center; justify-content:center; z-index:15;
  box-shadow:0 0 20px rgba(0,255,255,0.6),0 0 40px var(--neon-pink);
}
.memory-spot:after{ content:'‚ù§Ô∏è'; color:#fff; font-size:20px; line-height:1; font-weight:bold; animation:heart-beat 1s ease-in-out infinite; }


.modal-description {
    font-size: 12px;
}

/* Modal Blur Effect (Applied to game container when modal is open) */
#game-container.blurred {
 filter: blur(4px);
 transition: filter 0.3s ease;
}

/* MODALS - Holographic/CRT Style */
.modal {
 position: fixed;
 top: 50%;
 left: 50%;
 transform: translate(-50%,-50%) scale(1);
 width: 400px;
 max-width: calc(100vw - 40px);
 max-height: calc(100vh - 120px);
 overflow-y: auto;
 /* Holographic/CRT Colors */
 background: rgba(10, 0, 50, 0.9); /* Semi-transparent dark background */
 padding: 24px;
 border-radius: 0;
 /* Neon Border and Shadow */
 box-shadow: 0 0 10px var(--electric-cyan), 0 0 20px var(--neon-pink);
 border: 4px solid var(--electric-cyan);
 color: #fff;
 display: none;
 z-index: 9999;
 font-family: 'IBM Plex Mono', monospace; /* More readable body text */
 transition: transform 0.1s ease-out;
}
.modal.show{ display:block; }
.modal img{ width:100%; height:auto; border-radius: 0; margin-bottom: 12px; border: 3px solid var(--neon-pink); }
.modal h3 {
 /* Neon Title */
 text-align: center; border-bottom: 2px solid var(--neon-pink); padding-bottom: 8px; margin-top: 0; margin-bottom: 16px; font-size: 1.2em;
 color: var(--electric-cyan);
 text-shadow: 0 0 5px var(--electric-cyan);
}

/* BUTTONS */
.btn{
 /* Neon Pink Button Style */
 background:var(--neon-pink); color:#fff; border:4px solid var(--electric-cyan); padding: 8px 16px; border-radius: 0; cursor: pointer;
 box-shadow: 4px 4px 0 var(--electric-cyan); transition: all 0.05s ease-out; font-family: 'Press Start 2P', monospace; text-transform: uppercase; text-align: center;
}
.btn:hover{ background:#ff4fa3; }
.btn:active{
 transform: translate(2px, 2px);
 box-shadow: 2px 2px 0 var(--electric-cyan);
}
#stop-btn:hover { background: #d00 !important; }

/* ALPHABET LIST & GALLERY MODAL */
#alphabet-list, #polaroid-collage-container {
 max-height: 350px;
 overflow-y: auto;
}
#alphabet-list {
 display: flex; flex-wrap: wrap; justify-content: space-around;
 padding: 10px; background: rgba(0,0,0,0.5); border: 2px solid var(--electric-cyan);
}
.alpha-letter { width: 45%; margin-bottom: 10px; }
.alpha-letter h4 { margin: 0 0 5px 0; color: var(--neon-pink); font-size: 1em; text-shadow: 0 0 3px var(--neon-pink); }
.alpha-letter ul { list-style-type: '‚òÖ '; padding-left: 1.5em; margin: 0; font-size: 0.9em; font-family: 'IBM Plex Mono', monospace; }

#polaroid-collage-container {
 display: flex;
 flex-wrap: wrap;
 justify-content: center;
 align-items: flex-start;
 gap: 15px;
 padding: 15px;
 background: rgba(0,0,0,0.7);
 border: 4px solid var(--neon-pink);
 box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
}

/* Individual Polaroid Image Style */
.polaroid-image {
 background: #fff;
 padding: 8px 8px 25px 8px;
 border: 2px solid #000;
 box-shadow: 5px 5px 0px rgba(0,0,0,0.4), 0 0 10px rgba(255,255,255,0.2);
 position: relative;
 transform: rotate(var(--rotation));
 transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
 cursor: pointer;
 image-rendering: pixelated;
 max-width: 150px;
 flex-shrink: 0;
}
.polaroid-image:hover {
 transform: rotate(0deg) scale(1.1); /* Increased hover scale */
 box-shadow: 8px 8px 0px rgba(0,0,0,0.6), 0 0 25px var(--electric-cyan); /* Neon hover glow */
 z-index: 1;
}
.polaroid-image img {
 display: block; width: 100%; height: auto; border: 1px solid #aaa; margin-bottom: 5px;
}
.polaroid-image .caption {
 position: absolute; bottom: 5px; left: 0; width: 100%; text-align: center; font-size: 0.7em; color: #333; font-family: 'Press Start 2P', monospace;
 white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
/* HINT */
.hint{ position:fixed; left:12px; top:12px; color:var(--electric-cyan); background:rgba(0,0,0,0.9); padding:8px 12px; border-radius:0; border:2px solid var(--electric-cyan); font-size:12px; z-index:1000; box-shadow:4px 4px 0 rgba(0,0,0,0.6),0 0 10px var(--electric-cyan); text-shadow:0 0 5px var(--electric-cyan);}
.hint::before{ content:'CONTROLS: '; color:var(--neon-pink); }

/* MOBILE */
#mobile-controls{ position:fixed; bottom:20px; right:20px; display:flex; gap:20px; align-items:center; z-index:999; }
#joystick-container{ width:80px; height:80px; border:4px solid var(--electric-cyan); border-radius:50%; background:rgba(255,255,255,0.1); position:relative; touch-action:none; transition:opacity 0.2s;}
#joystick-container.active{ opacity:1; }
#joystick-container:not(.active){ opacity:0.5; }
#joystick-thumb{ width:50px; height:50px; background:var(--neon-pink); border:4px solid var(--electric-cyan); border-radius:50%; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); box-shadow:0 0 10px var(--neon-pink);}
#jump-btn{ position:fixed; bottom:20px; left:20px; width:70px; height:70px; border-radius:12px; background:var(--neon-pink); border:4px solid var(--electric-cyan); font-size:30px; color:#fff; text-align:center; line-height:70px; user-select:none; box-shadow:4px 4px 0 var(--electric-cyan);}
#jump-btn:active{ background:#e04090; box-shadow:2px 2px 0 var(--electric-cyan); }

/* KEYFRAMES */
@keyframes memory-float {0%{transform:translateY(0px);}50%{transform:translateY(-10px);}100%{transform:translateY(0px);}}
@keyframes heart-beat {0%{transform:scale(1);}15%{transform:scale(1.1);}30%{transform:scale(1);}100%{transform:scale(1);}}
@keyframes flap {0%,100%{transform:rotate(-20deg);}50%{transform:rotate(-45deg);}}
@keyframes flap-right {0%,100%{transform:rotate(20deg);}50%{transform:rotate(45deg);}}

@keyframes twinkle {
  0% { opacity: 0.8; }
  50% { opacity: 0.2; }
  100% { opacity: 0.8; }
}
</style>
</head>
<body>

<div class="hint">Use joystick or A/D/‚Üê ‚Üí to move ‚Ä¢ Spacebar/‚Üë/W to jump</div>
<div id="game-container">

  <div id="makkunii-pixel" style="position:absolute; width:100px; height:100px; bottom:120px; left:7800px; z-index:10;">
    <img src="./assets/images/makkunii.png" style="width:100%; height:100%; image-rendering:pixelated;" />
  </div>

  <div id="star-field" class="parallax-layer"></div>
  <div id="distant-mountains" class="parallax-layer"></div>
  <div id="close-clouds" class="parallax-layer"></div>

 <div id="player">
  <img id="mjay-pixel" src="./assets/images/mjay_standing_side_view.png" />

</div>

  <div id="ground"></div>
</div>

<div id="memory-modal" class="modal">
  <h3 id="memory-title"></h3>
  <img id="memory-img" src="" alt="" style="display:none"/>
  <div id="memory-text"></div>
  <p class="modal-description"></p>
  <div id="audio-player-container" style="display:none; margin-top:15px; padding:10px; background:#000; border:4px solid #333;">
    <audio id="memory-audio" style="display:none;"></audio>
    <div id="player-controls" style="display:flex; justify-content:space-between; align-items:center;">
      <button id="play-btn" class="btn" style="width:45%;">‚ñ∂ Play</button>
      <button id="stop-btn" class="btn" style="width:45%; background:#f00; border-color:#900;">‚ñ† Stop</button>
    </div>
    <div id="player-status" style="margin-top:10px; padding:5px; background:#222; border:2px solid #000; color:#0f0; font-size:14px; text-align:center;">
      <span id="player-time">0:00 / 0:00</span>
    </div>
  </div>
  <button id="close-memory" class="btn" style="width:100%; margin-top:15px;">Close</button>
</div>

<div id="alphabet-modal" class="modal">
  <h3>Alphabet Dating List</h3>
  <p class="modal-description"></p>
  <div id="alphabet-list"></div>
  <button id="close-alpha" class="btn" style="width:100%; margin-top:15px;">Close</button>
</div>

<div id="gallery-modal" class="modal">
  <h3>Our Memories</h3>
  <p class="modal-description"></p>
  <div id="polaroid-collage-container" class="gallery"></div>
  <button id="close-gallery" class="btn" style="width:100%;">Back</button>
</div>

<div id="ending-modal" class="modal">
  <h3 id="ending-title" style="color:#ff1493; font-size:1.5em;">You reached the end</h3>
  <div id="ending-text" style="text-align:center; font-size:1.1em; line-height:1.5;">
    <p>Congratulations!</p>
    <p>You've reached the very end of our Memory Lane.</p>
    <p>While the game world stops here, our real-life adventure is just beginning.</p>
    <p>I love you and look forward to building a world even bigger than this one, together.</p>
    <p style="margin-top:20px;">~ makkunii <span style="font-size:1.5em;">‚ù§Ô∏è</span></p>
  </div>
  <button id="close-ending" class="btn" style="width:100%; margin-top:20px;">Return to the World</button>
</div>

<div id="mobile-controls">
  <div id="joystick-container"><div id="joystick-thumb"></div></div>
  <div id="jump-btn" class="control-btn">‚¨Ü</div>
</div>

<script>
  // ----------------------------------------------------
// ‚öôÔ∏è GAME CONFIGURATION DATA (EASY TO EDIT) 
// ----------------------------------------------------
const GAME_DATA = {
    // Media for the Gallery Modal
    galleryImages: [
        './assets/images/zaky.jpg',
        './assets/images/zaky.jpg',
        './assets/images/zaky.jpg',
        './assets/images/zaky.jpg',
    ],
    // Data for the Alphabet Modal
    alphabetData: {
        A:['Aquarium Date','Arcade Date'], B:['Bowling','Beach'], C:['Coffee Date','Camping'],
        D:['Dinner Date','Drawing (Draw each other)'], E:['Escape Room','Evening stroll'], F:['Fireworks','Fun challenge'],
        G:['Go Shopping','Game Night'], H:['Hot Air Balloon','Hiking'], I:['Ice Skating','Ice Cream'],
        J:['Japanese dining','Jacuzzi'], K:['Karaoke','KFC'], L:['Live Concert','Lunch Date'],
        M:['Movie Marathon','Magic Show'], N:['Night Market','Netflix'], O:['Obstacle course','Online games'],
        P:['Pool Party','Photo Shoot'], Q:['Quiz Date','Quality time'], R:['Ramen Date','Roadtrip'],
        S:['Stargazing','Surprise'], T:['Travel Planning','Trampoline'], U:['Unwind','Ukulele Lesson'],
        V:['Vacation','Video Timelapse'], W:['Waterpark','Wedding'], X:['Xmas Party','X Marks the Spot'],
        Y:['Yes Challenge','Yogurt Date'], Z:['Zoo','Zip-line Adventure']
    },
    // Platform locations (bottom is height from ground, width is optional)
    platforms: [
        { left: 1200, bottom: 200, width: 200 },
        { left: 1500, bottom: 250, width: 300 },
        { left: 2800, bottom: 300, width: 200 },
        { left: 4500, bottom: 200, width: 400 },
    ],
    // Memory Spots (Memory spots should align with or float above a platform/ground)
    memorySpots: [
        { 
            left: 800, 
            bottom: 180, 
            type: 'photo', 
            text: 'We virtually met here in this app ‚ù§Ô∏è',
            description: `I remember when we first met, it was me who made the first move. <br /> <br />
            although it was all thanks to a common friend, it was all you that I fell inlove to <br /> <br /> 

            you even thought you were set up with someone who was married, luckily i was not haha <br /> <br />
            <img src="./assets/images/first_move.jpeg" alt="first move">` 
            ,  photo: './assets/images/zaky.jpg' },
        { left: 1650, bottom: 330, type: 'audio', text: 'Sinta - makkunii',description: 'At some point I found myself writing a song about you', audio: './assets/audio/sinta_makkunii.mp3' },
        { left: 3500, bottom: 180, type: 'alphabet', text: 'Our alphabet dating list', description: 'Remember when we made this list?' },
        { left: 4700, bottom: 280, type: 'gallery', text: 'Our first meetup gallery', description: 'Keeping this love in a photograph' },
        { left: 6500, bottom: 200, type: 'text', text: 'With you is like an adventure. Looking forward to more memories.' , description: 'No words needed, just looking forward.'}, // Added description here too
    ]
};
// ----------------------------------------------------

function isCollision(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + b.height > b.y
  );
}


// --- DOM Element Setup (Dynamically generated) ---
const gameContainer = document.getElementById('game-container');
const groundHeight = 120; // Must match CSS #ground height

// Function to generate the platforms and append to the game world
function initializeWorldElements() {
    // 1. Add Ground (already in HTML)

    // 2. Add Platforms
    GAME_DATA.platforms.forEach((p, index) => {
        const platformEl = document.createElement('div');
        platformEl.className = 'platform';
        platformEl.style.left = `${p.left}px`;
        platformEl.style.bottom = `${p.bottom}px`;
        if (p.width) {
            platformEl.style.width = `${p.width}px`;
        }
        platformEl.setAttribute('data-platform-id', `p${index + 1}`);
        gameContainer.appendChild(platformEl);
    });

    // 3. Add Memory Spots
    GAME_DATA.memorySpots.forEach((m, index) => {
        const spotEl = document.createElement('div');
        spotEl.className = 'memory-spot';
        spotEl.style.left = `${m.left}px`;
        // Spots float 10px above their base height
        spotEl.style.bottom = `${m.bottom}px`;
        spotEl.setAttribute('data-type', m.type);
        spotEl.setAttribute('data-text', m.text);
        if (m.photo) spotEl.setAttribute('data-photo', m.photo);
        if (m.audio) spotEl.setAttribute('data-audio', m.audio);
        spotEl.setAttribute('data-spot-id', `m${index + 1}`);
        gameContainer.appendChild(spotEl);
    });
}
initializeWorldElements();


// --- Player & Physics ---
const player=document.getElementById('player');
const mjayPixel=document.getElementById('mjay-pixel'); // Get the image element for sprite swapping
const gameWidth=8000;
const playerWidth=46;
let px=750, py=groundHeight, vx=0, vy=0; // Start player at left: 750px
const gravity=1.2, jumpStrength=22, acceleration=1, maxSpeed=8;
let isJumping=false, isModalOpen=false;

let canTriggerMemory = true;
let endingTriggered = false;


// Re-read platforms dynamically after they're created
const platforms=[];
document.querySelectorAll('.platform').forEach(el=>{
const width = parseInt(el.style.width) || 200;
platforms.push({el, left:parseInt(el.style.left), bottom:parseInt(el.style.bottom), width:width, height:20});
});

function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

// üèÉ‚Äç‚ôÄÔ∏è SPRITE DEFINITIONS
// IMPORTANT: Update these paths to match where your files are actually located!
const IDLE_SPRITE = './assets/images/mjay_standing_side_view.png'; 
const WALK_SPRITE_1 = './assets/images/mjay_walking_side_view.png'; 
// Since you only provided one walk sprite, we will use the standing one as the second frame.
const WALK_SPRITE_2 = './assets/images/mjay_standing_side_view.png'; 


let walkFrame = 0;
const WALK_CYCLE_INTERVAL = 150; // Milliseconds per frame swap
let lastWalkTime = 0;

function updateWalkAnimation(timestamp) {
    // Check if the player is moving horizontally
    const isMoving = Math.abs(vx) > 0.5 && !isModalOpen && !isJumping;

    if (isMoving) {
        player.classList.add('is-walking');

        // Check direction and flip sprite
        if (vx < -0.5) {
            player.style.transform = 'scaleX(-1)'; // Flip horizontally for left movement
        } else if (vx > 0.5) {
            player.style.transform = 'scaleX(1)'; // Default for right movement
        }
        
        // Sprite Swapping Logic
        if (timestamp - lastWalkTime > WALK_CYCLE_INTERVAL) {
            walkFrame = 1 - walkFrame; // Toggle between 0 and 1
            lastWalkTime = timestamp;
            
            if (walkFrame === 0) {
                mjayPixel.src = WALK_SPRITE_1; // Step 1: Walking sprite
            } else {
                mjayPixel.src = WALK_SPRITE_2; // Step 2: Standing sprite (or the second walk frame if you had one)
            }
        }

    } else {
        // Player is idle
        player.classList.remove('is-walking');
        mjayPixel.src = IDLE_SPRITE;
        walkFrame = 0; // Reset walk frame
    }
    
    // Check for jumping and add/remove class
    if (isJumping) {
        player.classList.add('is-jumping');
        mjayPixel.src = IDLE_SPRITE; // Show idle or a jump sprite when mid-air
    } else {
        player.classList.remove('is-jumping');
    }
}


// --- Game Loop (Physics Always Runs) ---
function updateGame(timestamp){
// Physics always runs, even when modal is open.
px+=vx; vx*=0.85; px=clamp(px,20,gameWidth-playerWidth-10);
vy-=gravity; py=clamp(py+vy,groundHeight,1000);

let restingY = groundHeight, onPlatform = false;
platforms.forEach(p => {
    const platformTopY = p.bottom + p.height;
    const isOverlapX = px < (p.left + p.width) && (px + playerWidth) > p.left;
    if (isOverlapX && py >= p.bottom && py < platformTopY && vy <= 0) {
        restingY = platformTopY;
        onPlatform = true;
        vy = 0;
        py = restingY;
    }
});

if(py<=groundHeight && vy<=0 && !onPlatform){ vy=0; py=groundHeight; }
isJumping = !onPlatform && py > groundHeight;
player.style.left=px+'px'; player.style.bottom=py+'px';
window.scrollTo({left:px-window.innerWidth/2+playerWidth/2, behavior:'auto'});

 // Parallax Logic
 const scrollOffset = px - (window.innerWidth / 2);
 document.getElementById('distant-mountains').style.backgroundPositionX = `${-scrollOffset * 0.1}px`;
 document.getElementById('close-clouds').style.backgroundPositionX = `${-scrollOffset * 0.3}px`;

updateWalkAnimation(timestamp); // üèÉ‚Äç‚ôÄÔ∏è Update the walk animation class here
checkMemoryTriggers();
checkEndingTrigger();

requestAnimationFrame(updateGame);
}
// Start the game loop with the timestamp argument
requestAnimationFrame(updateGame);

// üíñ ENDING TRIGGER FUNCTION
const endingModal = document.getElementById('ending-modal');
const closeEndingBtn = document.getElementById('close-ending');

const makkuniiEl = document.getElementById('makkunii-pixel');

function checkEndingTrigger() {
 if (px > 7800 && !endingTriggered && !isModalOpen) {
  openEndingModal();
 }
}


function openEndingModal() {
 isModalOpen = true;
 endingTriggered = true;
 vx = 0;
  // UX: Apply Blur to game container
  gameContainer.classList.add('blurred');
 endingModal.classList.add('show');
  // UX: Set focus to the close button for accessibility
  closeEndingBtn.focus();
}

// --- Controls (Keyboard) ---
const keys={};
document.addEventListener('keydown', e=>{
if(isModalOpen) return;
keys[e.key]=true;
if(e.key===' ' || e.key.startsWith('Arrow') || e.key==='w' || e.key==='a' || e.key==='d') e.preventDefault();
if((e.key===' '||e.key==='ArrowUp'||e.key==='w'||e.key==='W') && vy===0) vy=jumpStrength;
});
document.addEventListener('keyup', e=>{ keys[e.key]=false; });

function handleMovementInput(){
 if(!isModalOpen){
  if(keys['ArrowRight']||keys['d']||keys['D']) vx=clamp(vx+acceleration,-maxSpeed,maxSpeed);
  if(keys['ArrowLeft']||keys['a']||keys['A']) vx=clamp(vx-acceleration,-maxSpeed,maxSpeed);
 } else {
  // Allow velocity decay
 }
 requestAnimationFrame(handleMovementInput);
}
handleMovementInput();

// --- Interaction & Modals ---
// Removed global 'memDescription' reference to avoid ID conflicts.
const memModal=document.getElementById('memory-modal'), memImg=document.getElementById('memory-img'), memText=document.getElementById('memory-text'), memTitle=document.getElementById('memory-title'), audioPlayerContainer=document.getElementById('audio-player-container'), closeMem=document.getElementById('close-memory'), audioEl=document.getElementById('memory-audio');
const alphaModal=document.getElementById('alphabet-modal'), alphaList=document.getElementById('alphabet-list'), closeAlpha=document.getElementById('close-alpha');
const galleryModal=document.getElementById('gallery-modal'), closeGallery=document.getElementById('close-gallery');
const polaroidCollageContainer = document.getElementById('polaroid-collage-container');
const playBtn = document.getElementById('play-btn');
const stopBtn = document.getElementById('stop-btn');
const playerTime = document.getElementById('player-time');
let audioInterval;

function formatTime(seconds) {
const min = Math.floor(seconds / 60);
const sec = Math.floor(seconds % 60);
return `${min}:${sec < 10 ? '0' : ''}${sec}`;
}

function updateTimeDisplay() {
if (audioEl.readyState >= 2) {
 const current = formatTime(audioEl.currentTime);
 const duration = formatTime(audioEl.duration);
 playerTime.textContent = `${current} / ${duration}`;
} else {
 playerTime.textContent = 'Loading...';
}
}

function startAudioTimer() {
updateTimeDisplay();
audioInterval = setInterval(() => {
 updateTimeDisplay();
 if (audioEl.ended) {
 stopAudio();
 }
}, 1000);
}

function stopAudioTimer() {
clearInterval(audioInterval);
}

function playAudio() {
audioEl.play().then(() => {
 playBtn.textContent = '‚è∏ Pause';
 stopAudioTimer();
 startAudioTimer();
}).catch(e => {
 console.error("Audio playback failed:", e);
 playBtn.textContent = 'Error';
});
}

function pauseAudio() {
audioEl.pause();
playBtn.textContent = '‚ñ∂ Play';
stopAudioTimer();
}

function stopAudio() {
audioEl.pause();
audioEl.currentTime = 0;
playBtn.textContent = '‚ñ∂ Play';
stopAudioTimer();
updateTimeDisplay();
}

playBtn.addEventListener('click', () => {
if (audioEl.paused || audioEl.ended) {
 playAudio();
} else {
 pauseAudio();
}
});

stopBtn.addEventListener('click', stopAudio);


function renderAlphabet(){ 
    alphaList.innerHTML=''; 
    Object.keys(GAME_DATA.alphabetData).forEach(letter=>{
        const wrapper=document.createElement('div'); wrapper.className='alpha-letter';
        const h=document.createElement('h4'); h.textContent=letter;
        const ul=document.createElement('ul');
        GAME_DATA.alphabetData[letter].forEach(item=>{ const li=document.createElement('li'); li.textContent=item; ul.appendChild(li); });
        wrapper.appendChild(h); wrapper.appendChild(ul); alphaList.appendChild(wrapper);
    });
}
renderAlphabet();

function checkMemoryTriggers(){
// ADDED: Memory Interaction Hint & Pulse
let nearMemory = false;

document.querySelectorAll('.memory-spot').forEach(spot=>{
 const sx=parseInt(spot.style.left);
 const sy=parseInt(spot.style.bottom);
 const closeX=Math.abs(px-sx)<60;
 const closeY=Math.abs(py-(sy-10))<50;

 if (closeX && closeY) {
 nearMemory = true;
 spot.style.boxShadow = '0 0 25px var(--electric-cyan), 0 0 50px var(--neon-pink)';
 } else {
 spot.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.6), 0 0 40px var(--neon-pink)';
 }

 if(closeX && closeY && canTriggerMemory && !isModalOpen) {
 openMemorySpot(spot);
 }
});
}

function openMemorySpot(spot){
const type=spot.dataset.type||'text';
const text=spot.dataset.text||'';

// üåü CRITICAL: Find the corresponding data object to get the description
const spotLeft = parseInt(spot.style.left);
const spotData = GAME_DATA.memorySpots.find(m => m.left === spotLeft);
const description = spotData ? spotData.description : ''; 

const photo=spot.dataset.photo||'';
const audio=spot.dataset.audio||'';

if (isModalOpen) return;

isModalOpen = true;
canTriggerMemory = false;
vx = 0; // Stop player movement

// UX: Apply Blur to game container
gameContainer.classList.add('blurred');

// UX: Visual feedback for collection (temporarily remove spot after delay)
const originalStyle = spot.style.cssText;
spot.style.boxShadow = '0 0 50px #fff, 0 0 100px var(--neon-pink)';
spot.style.opacity = '0';

setTimeout(() => {
 // Restore original visual state after modal closes
 spot.style.opacity = '1';
 // Restore all original CSS styles
 spot.style.cssText = originalStyle; 
}, 1000);

// --- Determine Modal and Find Correct Description Element ---
let modalToOpen, closeBtn;

if(type==='photo' || type==='text' || type==='audio'){
    modalToOpen = memModal;
    closeBtn = closeMem;
}
else if(type==='alphabet'){
    modalToOpen = alphaModal;
    closeBtn = closeAlpha;
}
else if(type==='gallery'){
    modalToOpen = galleryModal;
    closeBtn = closeGallery;
}

// üåü FIX: Use the class selector on the specific modal element
const currentMemDescription = modalToOpen ? modalToOpen.querySelector('.modal-description') : null;

// Reset visual elements common to memory/text/audio
memTitle.style.display='block';
memImg.style.display='none';
audioPlayerContainer.style.display='none';

// üåü FIX: Clear the content using innerHTML on the correct element
if (currentMemDescription) currentMemDescription.innerHTML = ''; 

if(type==='photo' || type==='text' || type==='audio'){
 // Setup for memory modal
 if(type==='photo'){
 memImg.src=photo||'';
 memImg.style.display=photo?'block':'none';
 memText.textContent=text;
 memTitle.textContent='Fresh Start';
 if (currentMemDescription) currentMemDescription.innerHTML = description; // üåü USE INNERHTML FOR HTML CONTENT
 } else if(type==='audio'){
 memText.textContent=text;
 audioEl.src=audio||'';
 audioPlayerContainer.style.display=audio?'block':'none';
 memTitle.textContent='A song perhaps?';
 if (currentMemDescription) currentMemDescription.innerHTML = description; // üåü USE INNERHTML
 audioEl.load(); audioEl.onloadedmetadata = updateTimeDisplay; playerTime.textContent = 'Loading...'; playBtn.textContent = '‚ñ∂ Play';
 } else { // 'text' type
 memText.textContent=text;
 memTitle.textContent='To Mommy';
 if (currentMemDescription) currentMemDescription.innerHTML = description; // üåü USE INNERHTML
 }
}
else if(type==='alphabet'){
 // Alphabet Modal logic:
 memTitle.textContent='[DATA TYPE: ALPHABET]'; 
 if (currentMemDescription) currentMemDescription.innerHTML = description; // üåü USE INNERHTML
}
else if(type==='gallery'){
 // Renders the gallery content using the externalized data
 polaroidCollageContainer.innerHTML = '';
 GAME_DATA.galleryImages.forEach((imageUrl, index) => {
 const polaroidDiv = document.createElement('div');
 polaroidDiv.className = 'polaroid-image';
 const rotation = Math.random() * 10 - 5;
 polaroidDiv.style.setProperty('--rotation', `${rotation}deg`);

 const imgElement = document.createElement('img');
 imgElement.src = imageUrl;
 imgElement.alt = `Memory ${index + 1}`;

 const captionElement = document.createElement('div');
 captionElement.className = 'caption';
 captionElement.textContent = `Moment ${index + 1}`;

 polaroidDiv.appendChild(imgElement);
 polaroidDiv.appendChild(captionElement);
 polaroidCollageContainer.appendChild(polaroidDiv);
 });
 
 memTitle.textContent='[DATA TYPE: GALLERY]'; 
 if (currentMemDescription) currentMemDescription.innerHTML = description; // üåü USE INNERHTML
}

if (modalToOpen) {
 modalToOpen.classList.add('show');
  // UX: Set focus to the close button
  closeBtn.focus();
}
}

function closeAllModals(){
memModal.classList.remove('show');
alphaModal.classList.remove('show');
galleryModal.classList.remove('show');
endingModal.classList.remove('show');
isModalOpen=false;
stopAudio();

// UX: Remove Blur from game container
gameContainer.classList.remove('blurred');

// FIX: Zero out horizontal velocity on close.
vx = 0;

// Re-enable memory trigger after a short delay (500ms cooldown)
setTimeout(() => {
 canTriggerMemory = true;
}, 500);
}

closeMem.onclick=closeAllModals;
closeAlpha.onclick=closeAllModals;
closeGallery.onclick=closeAllModals;
closeEndingBtn.onclick=closeAllModals;

// Attach click listeners to all memory spots (after they are created by initializeWorldElements)
document.querySelectorAll('.memory-spot').forEach(s=> s.addEventListener('click', ()=> {
if(!isModalOpen) {
 openMemorySpot(s);
}
}));
// Added Enter key listener to close modals
window.addEventListener('keydown', e=>{
  if(e.key==='Escape' || e.key==='Enter' && isModalOpen) closeAllModals();
});


// --- Mobile Joystick ---
const joystickContainer = document.getElementById('joystick-container');
const joystickThumb = document.getElementById('joystick-thumb');
const jumpBtn = document.getElementById('jump-btn');
let joystickActive=false, startX=0, moveX=0;

joystickContainer.addEventListener('touchstart', e=>{
if(isModalOpen) return;
e.preventDefault();
joystickActive=true;
// UX: Set Opacity Active
joystickContainer.classList.add('active');
const touch=e.touches[0];
startX=touch.clientX;
const rect = joystickContainer.getBoundingClientRect();
const x = touch.clientX - rect.left;
const y = touch.clientY - rect.top;
joystickThumb.style.left = `${x}px`;
joystickThumb.style.top = `${y}px`;
});
joystickContainer.addEventListener('touchmove', e=>{
if(!joystickActive || isModalOpen) return;
e.preventDefault();
const touch=e.touches[0];
const rect = joystickContainer.getBoundingClientRect();
const centerX = rect.width / 2;
const centerY = rect.height / 2;
let x = touch.clientX - rect.left;
let y = touch.clientY - rect.top;
const maxDist = 40;
const dx = x - centerX;
const dy = y - centerY;
const dist = Math.sqrt(dx * dx + dy * dy);

if (dist > maxDist) {
 x = centerX + (dx / dist) * maxDist;
 y = centerY + (dy / dist) * maxDist;
}

joystickThumb.style.left = `${x}px`;
joystickThumb.style.top = `${y}px`;

moveX = x - centerX;
vx = clamp(moveX / 5, -maxSpeed, maxSpeed);

});
joystickContainer.addEventListener('touchend', e=>{
if(!joystickActive) return;
joystickActive=false;
// UX: Set Opacity Inactive
joystickContainer.classList.remove('active');
joystickThumb.style.left = '50%';
joystickThumb.style.top = '50%';
if (!isModalOpen) {
 vx=0;
}
});

// Jump button
jumpBtn.addEventListener('touchstart', (e)=>{
if(isModalOpen) return;
e.preventDefault();
if(vy===0) vy=jumpStrength;
});

// --- Dynamic Stars ---
const starField = document.getElementById('star-field');
const numberOfStars = 100;

function createTwinklingStars() {
 for (let i = 0; i < numberOfStars; i++) {
  const star = document.createElement('div');
  star.style.position = 'absolute';
 
  // Random position within the entire 8000px game world
  star.style.left = `${Math.random() * gameWidth}px`;
  star.style.top = `${Math.random() * (window.innerHeight * 0.7)}px`;
 
  const size = Math.random() > 0.9 ? '2px' : '1px';
  star.style.width = size;
  star.style.height = size;
  star.style.background = '#fff';
  star.style.boxShadow = `0 0 2px 0 #fff`;
 
  star.style.animation = `twinkle 1s ease-in-out ${Math.random() * 0.5 + 0.5}s infinite alternate`;
  star.style.animationDelay = `${Math.random() * 5}s`;

  starField.appendChild(star);
 }
}

createTwinklingStars();
</script>

</body>
</html>